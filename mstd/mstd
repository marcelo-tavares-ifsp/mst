#!/usr/bin/guile \
-e main -s
# aside from this initial boilerplate, this is actually -*- scheme -*- code
!#

;;; mstd -- MST daemon.

;; Copyright (C) 2020 "AZ Company Group" LLC <https://gkaz.ru/>
;;
;; This program is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along with
;; this program. If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; mstd -- The MST daemon that listens to USB device states by means of udev and
;; mounts attached USB devices for the multi-seat users.


;;; Code:

(use-modules (udev udev)
             (udev monitor)
             (udev device)
             (ice-9 popen)
             (ice-9 getopt-long))


;;; Global constants and variables:

(define %default-pid-file      "/var/run/mstd.pid")

(define *debug?* #f)


(define (display-number->user display-number)
  "Find out the user by its display number."
  (let ((port (open-input-pipe
               (string-append
                "who"
                " | "
                (format #f "grep '(:~d)'" display-number)
                " | "
                "sed -re 's/^([^ ]+) +.* \\(:[0-9]+\\)/\\1/g'"
                " | "
                "head -1"))))
    (read-line port)))

;; TODO:
;; (define (device-path->display-number device-path)
;;   )

(define (mount device user)
  "Mount a DEVICE for a USER by means of udisksctl command."
  (system (string-append
           (format #f "sudo --user='~s' -- " user)
           "udisksctl mount --no-user-interaction --block-device "
           device)))

(define (callback device)
  (display "device: ")
  (display (udev-device-get-devpath device))
  (newline))

(define (start-listener)
  "Start udev listener."
  (let* ((udev         (make-udev))
         (udev-monitor (make-udev-monitor udev)))
    (udev-monitor-add-filter! udev-monitor "usb" "usb_device")
    (udev-monitor-set-callback! udev-monitor callback)
    (udev-monitor-start-scanning! udev-monitor)
    (while #t
      (sleep 1))))

(define *option-spec*
  '((pid-file                 (value #t))
    (detach                   (value #f))
    (help   (single-char #\h) (value #f))))

(define (write-pid pid-file)
  "Write the process PID to a specified PID-FILE."
  (let ((p (open-output-file pid-file)))
    (write (getpid) p)
    (close p)))

(define (print-help-and-exit)
  "Print the help message and exit."
  (display (string-append "\
Usage: mstd [ options ]

Options:
  --detach                      Detach mode.
  --debug                       Debug mode.
  --pid-file=<file-name>        File to store PID after the server starts to
                                listen to the socket.
                                Default: " %default-pid-file "
  --help, -h                    Print this message and exit.
"))
  (exit))


(define (main args)
  "Program entry point."
  (let* ((options       (getopt-long args *option-spec*))
         (detach-wanted (option-ref options 'detach   #f))
         (pid-file      (option-ref options 'pid-file %default-pid-file))
         (debug-wanted? (option-ref options 'debug    #f))
         (help-wanted?  (option-ref options 'help     #f)))

    (when help-wanted?
      (print-help-and-exit))

    (set! *debug?* debug-wanted?)

    (when detach-wanted
      (let ((pid (primitive-fork)))
        (cond
         ((zero? pid)
          (close-ports)
          (setsid))
         ((> pid 0)
          (exit))
         (#t
          (error "Could not fork the process.")))))

    (write-pid pid-file)

    (start-listener)))

;;; mstd ends here.
