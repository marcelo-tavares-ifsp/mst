#!/usr/bin/guile \
-e main -s
# aside from this initial boilerplate, this is actually -*- scheme -*- code
!#

;;; mstd -- MST daemon.

;; Copyright (C) 2020 "AZ Company Group" LLC <https://gkaz.ru/>
;; Copyright (C) 2020 Artyom V. Poptsov <a@gkaz.ru>
;;
;; This program is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along with
;; this program. If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; mstd -- The MST daemon that listens to USB device states by means of udev and
;; mounts attached USB devices for the multi-seat users.


;;; Code:

(use-modules (udev udev)
             (udev monitor)
             (udev device)
             (ice-9 popen)
             (ice-9 rdelim)
             (ice-9 getopt-long))


;;; Global constants and variables:

(define %default-pid-file      "/var/run/mstd.pid")
(define %seat-configuration-file "/etc/mst-seats")

(define *debug?* #f)


(define (display-number->user display-number)
  "Find out the user by its display number.  Return user name or #f if the
user is not found."
  (let ((port (open-input-pipe
               (string-append
                "who"
                " | "
                (format #f "grep '(:~a)'" display-number)
                " | "
                "sed -re 's/^([^ ]+) +.* \\(:[0-9]+\\)/\\1/g'"
                " | "
                "head -1"))))
    (let ((result (read-line port)))
      (if (not (eof-object? result))
          result
          #f))))

(define (read-seats-configuration config-file)
  (let ((port (open-input-file config-file)))
    (let read ((line (read-line port))
               (data '()))
      (if (eof-object? line)
          data
          (read (read-line port)
                (cons (string-split line #\space) data))))))

(define (device-path->display-number config device-path)
  (let* ((record       (car config))
         (base-devpath (car record)))
    (if (string-contains device-path base-devpath)
        (cadr record)
        (if (null? (cdr config))
            #f
            (device-path->display-number (cdr config) device-path)))))

(define (mount device user)
  "Mount a DEVICE for a USER by means of udisksctl command."
  (let ((command (string-append
                  (format #f "sudo --user='~a' -- " user)
                  "udisksctl mount --no-user-interaction --block-device "
                  device)))
    (when *debug?*
      (format #t "mount command: ~a~%" command))
    (system command)))

(define (notify-send display-number message)
  "Show a notify with a MESSAGE on the given DISPLAY-NUMBER."
  (system (string-append
           (format #f "DISPLAY=:~a" display-number)
           " /usr/bin/notify-send"
           " --urgency=critical"
           " --icon=error"
           (string-append " '" message "'"))))

(define (notify-broadcast config message)
  "Broadcast a notify with a MESSAGE across all seats that are listed
in a CONFIG."
  (for-each (lambda (rec)
              (notify-send (cadr rec) message))
            config))

(define (start-listener config)
  "Start udev listener."
  (let* ((udev         (make-udev))
         (udev-monitor (make-udev-monitor udev))
         (udev-input-monitor (make-udev-monitor udev)))
    (when *debug?*
      (format #t "Config: ~a~%" config))

    (udev-monitor-add-filter! udev-monitor       "block" "partition")
    (udev-monitor-add-filter! udev-input-monitor "usb"   "usb_device")

    (let ((callback
           (lambda (device)
             (when (string=? (udev-device-get-action device) "add")
               (let* ((devpath        (udev-device-get-devpath device))
                      (display-number (device-path->display-number config
                                                                   devpath))
                      (user           (display-number->user display-number))
                      (devname (udev-device-get-property-value device
                                                               "DEVNAME")))
                 (if user
                     (begin
                       (when *debug?*
                             (format #t "Mounting ~a for seat ~a (user ~a)~%"
                                     devpath display-number user))
                       (mount devname user))
                     (display "Could not determine user.")))))))

      (udev-monitor-set-callback! udev-monitor callback))

    (let ((callback
           (lambda (device)
             (let ((action  (udev-device-get-property-value device "ACTION"))
                   (devname (udev-device-get-property-value device
                                                            "DEVNAME"))
                   (devpath (udev-device-get-devpath device)))
               (cond
                ((string=? action "remove")
                 (when *debug?*
                   (format #t "Device ~a was removed.~%" devname))
                 (unless (device-path->display-number config devpath)
                   (notify-broadcast config
                                     (format #f
                                             (string-append
                                              "Seat input device ~a was removed.~%"
                                              "Please re-connect the device and"
                                              " reboot the computer.")
                                             devname))))
                ((string=? action "add")
                 (format #t "Device ~a was added.~%" devname)))))))
      (udev-monitor-set-callback! udev-input-monitor callback))

    (udev-monitor-start-scanning! udev-monitor)
    (udev-monitor-start-scanning! udev-input-monitor)
    (while #t
      (sleep 1))))

(define *option-spec*
  '((pid-file                 (value #t))
    (detach                   (value #f))
    (debug                    (value #f))
    (help   (single-char #\h) (value #f))))

(define (write-pid pid-file)
  "Write the process PID to a specified PID-FILE."
  (let ((p (open-output-file pid-file)))
    (write (getpid) p)
    (close p)))

(define (print-help-and-exit)
  "Print the help message and exit."
  (display (string-append "\
Usage: mstd [ options ]

Options:
  --detach                      Detach mode.
  --debug                       Debug mode.
  --pid-file=<file-name>        File to store PID after the server starts to
                                listen to the socket.
                                Default: " %default-pid-file "
  --help, -h                    Print this message and exit.
"))
  (exit))


(define (main args)
  "Program entry point."
  (let* ((options       (getopt-long args *option-spec*))
         (detach-wanted (option-ref options 'detach   #f))
         (pid-file      (option-ref options 'pid-file %default-pid-file))
         (debug-wanted? (option-ref options 'debug    #f))
         (help-wanted?  (option-ref options 'help     #f)))

    (when help-wanted?
      (print-help-and-exit))

    (set! *debug?* debug-wanted?)

    (when detach-wanted
      (let ((pid (primitive-fork)))
        (cond
         ((zero? pid)
          (setsid))
         ((> pid 0)
          (exit))
         (#t
          (error "Could not fork the process.")))))

    (write-pid pid-file)

    (start-listener (read-seats-configuration %seat-configuration-file))))

;;; mstd ends here.
