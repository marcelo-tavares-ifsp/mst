#!/usr/bin/guile \
-e main -s
# aside from this initial boilerplate, this is actually -*- scheme -*- code
!#

;;; mstd -- MST daemon.

;; Copyright (C) 2020-2021 "AZ Company Group" LLC <https://gkaz.ru/>
;; Copyright (C) 2020-2021 Artyom V. Poptsov <a@gkaz.ru>
;;
;; This program is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along with
;; this program. If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; mstd -- The MST daemon that listens to USB device states by means of udev and
;; mounts attached USB devices for the multi-seat users.


;;; Code:

(use-modules (udev udev)
	     (udev monitor)
	     (udev device)
	     (ice-9 popen)
	     (ice-9 rdelim)
	     (ice-9 getopt-long)
	     (mst config)
	     (mst system)
             (mst log)
	     (mst dm))


;;; Global constants and variables:

(define %default-pid-file      "/var/run/mstd.pid")
(define %seat-configuration-file "/etc/mst-seats")

(define *debug?* #f)


(define (device-path->display-number config device-path)
  "Try to determine a display number that device specified by its
DEVICE-PATH belongs to, using a CONFIG."
  (let* ((record       (car config))
	 (base-devpath (car record)))
    (if (string-contains device-path base-devpath)
	(cadr record)
	(if (null? (cdr config))
	    #f
	    (device-path->display-number (cdr config) device-path)))))

(define (notify-broadcast config message)
  "Broadcast a notify with a MESSAGE across all seats that are listed
in a CONFIG."
  (for-each (lambda (rec)
	      (notify-send (cadr rec) message))
	    config))

(define (start-listener config)
  "Start udev listener."
  (let* ((udev         (make-udev))
	 (udev-monitor (make-udev-monitor udev
					  #:timeout-sec 1
					  #:filter '("block" "partition")))
	 (udev-input-monitor (make-udev-monitor udev
						#:timeout-sec 1
						#:filter '("usb" "usb_device"))))
    (log-info "Config: ~a~%" config)

    (let ((callback
	   (lambda (device)
	     (when (string=? (udev-device-get-action device) "add")
	       (let* ((devpath        (udev-device-get-devpath device))
		      (display-number (device-path->display-number config
								   devpath))
		      (user           (display-number->user display-number))
		      (devname (udev-device-get-property-value device
							       "DEVNAME")))
		 (if user
		     (begin
                       (log-info "Mounting ~a for seat ~a (user ~a)~%"
                                 devpath display-number user)
		       (mount devname user))
		     (display "Could not determine user.")))))))

      (udev-monitor-set-callback! udev-monitor callback))

    (let ((callback
	   (lambda (device)
	     (let ((action  (udev-device-get-property-value device "ACTION"))
		   (devname (udev-device-get-property-value device
							    "DEVNAME"))
		   (devpath (udev-device-get-devpath device)))
	       (cond
		((string=? action "remove")
                 (log-info "Device ~a was removed.~%" devname)
		 (unless (device-path->display-number config devpath)
		   (notify-broadcast config
				     (format #f
					     (string-append
					      "Seat input device ~a was removed.~%"
					      "Please re-connect the device and"
					      " reboot the computer.")
					     devname))))
		((string=? action "add")
		 (log-info "Device ~a was added.~%" devname)))))))
      (udev-monitor-set-callback! udev-input-monitor callback))

    (udev-monitor-start-scanning! udev-monitor)
    (udev-monitor-start-scanning! udev-input-monitor)
    (while #t
      (sleep 1))))

(define *option-spec*
  '((pid-file                 (value #t))
    (detach                   (value #f))
    (debug                    (value #f))
    (help   (single-char #\h) (value #f))))

(define (write-pid pid-file)
  "Write the process PID to a specified PID-FILE."
  (let ((p (open-output-file pid-file)))
    (write (getpid) p)
    (close p)))

(define (print-help-and-exit)
  "Print the help message and exit."
  (display (string-append "\
Usage: mstd [ options ]

Options:
  --detach                      Detach mode.
  --debug                       Debug mode.
  --pid-file=<file-name>        File to store PID after the server starts to
				listen to the socket.
				Default: " %default-pid-file "
  --help, -h                    Print this message and exit.
"))
  (exit))


(define (main args)
  "Program entry point."
  (let* ((options       (getopt-long args *option-spec*))
	 (detach-wanted (option-ref options 'detach   #f))
	 (pid-file      (option-ref options 'pid-file %default-pid-file))
	 (debug-wanted? (option-ref options 'debug    #f))
	 (help-wanted?  (option-ref options 'help     #f)))

    (when help-wanted?
      (print-help-and-exit))

    (set! *debug?* debug-wanted?)
    (set-system-debug! debug-wanted?)

    (when detach-wanted
      (let ((pid (primitive-fork)))
        (cond
         ((zero? pid)
          (setsid))
         ((> pid 0)
          (exit))
         (#t
          (log-error "Could not fork the process.")
          (error "Could not fork the process.")))))

    (write-pid pid-file)

    (let ((config (read-seats-configuration %seat-configuration-file)))
      (dm-start (length config))
      (start-listener config))))

;;; mstd ends here.
